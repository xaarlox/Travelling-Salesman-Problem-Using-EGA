# Побудова генетичного алгоритму
## Завдання
Задача комівояжера (Travelling Salesman Problem): Мінімізація відстані, яку потрібно подолати продавцеві, щоб відвідати кожного клієнта точно один раз і повернутися в точку виходу.
## Реалізація завдання
*Що таке генетичний алгоритм?*

[Генетичний алгоритм](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC) – це еволюційний алгоритм пошуку, що використовується для вирішення задач оптимізації і моделювання шляхом послідовного підбору, комбінування і варіації шуканих параметрів з використанням механізмів, що нагадують біологічну еволюцію.

Особливістю генетичного алгоритму є акцент на використання оператора «схрещення», який виконує операцію рекомбінацію рішень-кандидатів, роль якої аналогічна ролі схрещення в живій природі.

*Який клас задач вирішує генетичний алгоритм?*

Генетичні алгоритми застосовується для вирішення наступних [задач](https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%BD%D0%B8%D0%B9_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC):
1. Оптимізація функцій
2. Оптимізація запитів в базах даних
3. Різноманітні задачі на графах (задача комівояжера, розфарбування)
4. Налаштування і навчання штучної нейронної мережі
5. Задачі компоновки
6. Створення розкладів
7. Ігрові стратегії
8. Апроксимація функцій
9. Штучне життя
10. Біоінформатика (згортання білків)
11. Синтез конструкцій антен

*Чому задачі, які вирішує генетичний алгоритм, відносяться до кіберфізичних систем?*

Було знайдено [статтю](https://www.researchgate.net/publication/350831890_An_Improved_Genetic_Algorithm_for_Safety_and_Availability_Checking_in_Cyber-Physical_Systems), у якій розглядається проблема перевірки персоналізованої політики доступу (PPC), яка враховує особливості користувачів та дозволів. Це критично важливо для забезпечення:
+ безпеки,
+ доступності,
+ ефективності

у кіберфізичних системах з великою кількістю пристроїв.

Оскільки задача PPC є обчислювально складною (NP-повною), автори пропонують застосувати бінарний генетичний алгоритм (BGS). Цей алгоритм:
- еволюційно шукає оптимальне рішення,
- враховує особливості доступу в реальному КФС-середовищі,
- ефективний у великих масштабах, де важлива швидкість обчислення, навіть за деякою втратою точності.

Таким чином, генетичний алгоритм виступає ключовим інструментом для розв’язання складних задач у КФС, оскільки:
* працює з динамічними і розподіленими середовищами (як КФС і IoT),
* допомагає адаптувати політики доступу під конкретні вимоги реального часу,
* забезпечує баланс між безпекою, доступністю і обчислювальною ефективністю, що є критичним для кіберфізичних систем.

## Код
Було написано програму, яка реалізовує елітний генетичний алгоритм для вирішення задачі комівояжера (TSP). Алгоритм шукає найкоротший маршрут між заданими містами, використовуючи відбір, схрещування, мутацію та елітизм.

Зупинимося на струткурі проєкту та модулях.
1. **crossover.py**. У цьому файлі є функція `ordered_crossover(parent1, parent2)`, яка реалізовує упорядковане схрещування. Частина маршруту береться від parent1, а інші міста вставляються з parent2 у порядку збереження. Повертається новий маршрут – дитина.
2. **mutation.py**. Функція `mutate(route, mutation_rate)` з імовірністю mutation_rate випадково міняє місцями два міста в маршруті та забезпечує генетичну різноманітність.
3. **selection.py**. Функція `tournament_selection(population, k)` вибирає k особин випадково, з них повертає найкращу (з найменшою відстаню). Дана функція використовується для селекції батьків.
4. **utils.py**. У цьому файлі є 2 функції. `calc_distance(cities)` обчислює повну довжину маршруту по Евклідовій відстані. `get_user_input()` збирає параметри від користувача для запуску алгоритму (розмір популяції, ймовірності тощо).
5. **population.py**. Функція `select_population(cities, size, quality)` генерує стартову популяцію маршрутів із випадкових перестановок міст, а аргумент quality змінює кількість згенерованих кандидатів (чим вища якість, тим більше відбір).
6. **evolution.py**. У даному файлі (функції) реалізований основний цикл еволюції популяції:
   + елітизм (залишає 2 найкращі маршрути);
   + турнірний відбір батьків;
   + схрещування та мутація;
   + обчислення відстані;
   + повертає відсортовану популяцію.
  
  7. **main.py**. Основні функції цього фалйу:
     * load_cities(filepath) – читає координати міст з файлу;
     * draw_map(route) – візуалізує маршрут на графіку.
     * run_ga(...) – керує всією логікою:
       - завантажує дані;
       - ініціалізує популяцію;
       - запускає цикл поколінь;
       - стежить за покращенням результату;
       - малює найкращий знайдений маршрут.

  8. **test_genetic.py**. Покриває юніт-тестами всі ключові функції:
     + перевірка правильності обчислення відстані;
     + валідність популяції;
     + генетичні оператори (схрещення, мутація);
     + селекція;
     + цілісність та сталість розміру популяції після еволюції.
  
## Висновок
[Генетичний алгоритм](https://www.quora.com/What-is-more-efficient-at-finding-a-solution-for-the-traveling-salesman-problem-a-purely-random-search-or-a-genetic-algorithm-Is-there-a-paper) є ефективним підходом до розв’язання задачі комівояжера, особливо у випадках з великою кількістю міст. На відміну від випадкового пошуку, який генерує рішення без урахування попередніх результатів, генетичний алгоритм використовує принципи природного добору: відбір, кросовер (схрещування) та мутацію. Завдяки цим механізмам, алгоритм поступово покращує якість рішень, еволюціонуючи популяцію кандидатів у напрямку до оптимального маршруту.

Дослідження показують, що генетичні алгоритми не тільки швидше сходяться до розв’язку, але й здатні знаходити високоякісні (наближено оптимальні) маршрути значно ефективніше, ніж простий випадковий пошук. Таким чином, генетичний алгоритм є перспективним і практичним інструментом для обчислювального розв’язання задачі комівояжера.
